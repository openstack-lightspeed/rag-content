#!/usr/bin/env python3
"""
AI: File generated by Cursor

Pandoc filter to improve DocBook to Markdown conversion for documentation:
1. Add book title from <info><title> as first H1 without affecting subsequent header levels
2. Convert <itemizedlist><title> and <orderedlist><title> to headers
3. Remove unnecessary blank lines between list items
"""

import sys
import json


def extract_string(inlines):
    """Extract plain text from inline elements"""
    if not inlines:
        return ""

    text = []
    for inline in inlines:
        if isinstance(inline, dict):
            if inline.get("t") == "Str":
                text.append(inline["c"])
            elif inline.get("t") == "Space":
                text.append(" ")
            elif inline.get("t") in ["Strong", "Emph", "Code"]:
                # Recursively extract from these
                if isinstance(inline.get("c"), str):
                    text.append(inline["c"])
                elif isinstance(inline.get("c"), list) and len(inline["c"]) > 1:
                    text.append(extract_string(inline["c"]))
            elif "c" in inline and isinstance(inline["c"], list):
                text.append(extract_string(inline["c"]))
    return "".join(text)


def process_blocks(blocks):
    """Process a list of blocks, converting special Divs to Headers and fixing list spacing"""
    new_blocks = []
    current_level = 0  # Track current section level

    for i, block in enumerate(blocks):
        if not isinstance(block, dict):
            new_blocks.append(block)
            continue

        block_type = block.get("t")

        # Track if we're in a list context
        if block_type in ["BulletList", "OrderedList"]:
            # Check if list has a title (DefinitionList with single term)
            # In DocBook, <itemizedlist><title> gets converted to a DefinitionList
            # Look ahead to see if next block is a list that should have this as title
            if i > 0:
                prev_block = blocks[i - 1]
                if (
                    isinstance(prev_block, dict)
                    and prev_block.get("t") == "DefinitionList"
                ):
                    # This might be a list title, convert it to header
                    def_list = prev_block.get("c", [])
                    if len(def_list) == 1:
                        term_inlines = def_list[0][0]
                        # Remove the DefinitionList from new_blocks and add as header
                        if new_blocks and new_blocks[-1] == prev_block:
                            new_blocks.pop()
                            # Keep original formatting in header
                            header_level = current_level + 1 if current_level > 0 else 3
                            header = {
                                "t": "Header",
                                "c": [header_level, ["", [], []], term_inlines],
                            }
                            new_blocks.append(header)

            # Process list items to remove extra spacing
            if block_type == "BulletList":
                list_items = block.get("c", [])
                new_list_items = []
                for item in list_items:
                    # Each item is a list of blocks
                    # Remove trailing Para blocks that are empty or just whitespace
                    if item and isinstance(item, list):
                        cleaned_item = []
                        for item_block in item:
                            if (
                                isinstance(item_block, dict)
                                and item_block.get("t") == "Para"
                            ):
                                # Keep the Para, it's the content
                                cleaned_item.append(item_block)
                            elif (
                                isinstance(item_block, dict)
                                and item_block.get("t") != "Para"
                            ):
                                cleaned_item.append(item_block)
                        new_list_items.append(cleaned_item)
                    else:
                        new_list_items.append(item)

                new_blocks.append({"t": "BulletList", "c": new_list_items})
            elif block_type == "OrderedList":
                # Similar processing for ordered lists
                list_attrs = block.get("c", [[], []])[0]
                list_items = block.get("c", [[], []])[1]
                new_list_items = []
                for item in list_items:
                    if item and isinstance(item, list):
                        cleaned_item = []
                        for item_block in item:
                            if (
                                isinstance(item_block, dict)
                                and item_block.get("t") == "Para"
                            ):
                                cleaned_item.append(item_block)
                            elif (
                                isinstance(item_block, dict)
                                and item_block.get("t") != "Para"
                            ):
                                cleaned_item.append(item_block)
                        new_list_items.append(cleaned_item)
                    else:
                        new_list_items.append(item)

                new_blocks.append(
                    {"t": "OrderedList", "c": [list_attrs, new_list_items]}
                )
            else:
                new_blocks.append(block)

            continue

        # Update current level when we see a Header
        if block_type == "Header":
            current_level = block["c"][0]  # First element is the level
            new_blocks.append(block)

        # Convert formalpara Div to Header
        elif block_type == "Div":
            attrs = block.get("c", [[], []])[0]  # [id, classes, key-value pairs]
            classes = attrs[1] if len(attrs) > 1 else []
            content = block.get("c", [[], []])[1]  # blocks inside the div

            if "formalpara-title" in classes and content:
                # This is a formalpara title - convert to header
                # The content should be a single Para
                first_block = content[0]
                if first_block.get("t") == "Para":
                    para_inlines = first_block.get("c", [])
                    # Create header with original formatting preserved
                    header_level = current_level + 1

                    header = {
                        "t": "Header",
                        "c": [header_level, ["", [], []], para_inlines],
                    }
                    new_blocks.append(header)
                else:
                    # Unexpected structure, keep as-is
                    new_blocks.append(block)
            else:
                # Not a formalpara, keep as-is
                new_blocks.append(block)

        # Handle DefinitionList that might be list titles
        elif block_type == "DefinitionList":
            # Check if next block is a list
            is_list_title = False
            if i + 1 < len(blocks):
                next_block = blocks[i + 1]
                if isinstance(next_block, dict) and next_block.get("t") in [
                    "BulletList",
                    "OrderedList",
                ]:
                    # This is likely a list title, it will be processed when we hit the list
                    is_list_title = True

            if not is_list_title:
                new_blocks.append(block)
            else:
                # This will be converted to a header when we process the next list
                new_blocks.append(block)

        else:
            # Other block types, keep as-is
            new_blocks.append(block)

    return new_blocks


def extract_title_inlines(title_meta):
    """Convert title metadata to inline elements for header"""
    if isinstance(title_meta, dict) and title_meta.get("t") == "MetaInlines":
        return title_meta.get("c", [])
    return []


def main():
    # Read JSON from stdin
    doc = json.load(sys.stdin)

    # Extract book title from metadata
    book_title_inlines = None
    if "meta" in doc and "title" in doc["meta"]:
        title_meta = doc["meta"]["title"]
        book_title_inlines = extract_title_inlines(title_meta)

    # Process blocks
    if "blocks" in doc:
        doc["blocks"] = process_blocks(doc["blocks"])

        # Add book title as first H1
        # Note: We don't adjust subsequent header levels because they should maintain
        # their relative structure from the original document
        if book_title_inlines:
            title_header = {"t": "Header", "c": [1, ["", [], []], book_title_inlines]}
            doc["blocks"].insert(0, title_header)

    # Write JSON to stdout
    json.dump(doc, sys.stdout)


if __name__ == "__main__":
    main()
